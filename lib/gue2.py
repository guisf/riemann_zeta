#!/usr/bin/env python

"""
Compute pair correlation function for Riemann zeros.
This is a slightly modification of Montgomery's conjecture, taking
into account the high density of zeros at higher points on the line.

When you start with the first zero it does not reproduce the same
graph as the pure Montgomery's conjecture. But when you start going
higher on the line the results seems better.

Guilherme S. Franca <guifranca@gmail.com>
29 Jun 2013
Physics Department, Cornell University

"""

from mpmath import *
from numpy import arange

mp.dps = 15
#pretty = True

def get_zeros(m, n, filename, starting=0):
    """We get zeros from `filename`. The file must be prepared in such
    a way that contains the interval of interest, starting from the
    lowest to the highest zero. We also take the first and last
    zeros that correspond to the size on the line, i.e. `t1` and `t2`.
    
    """
    if starting:
        m = m+1- starting
        n = n+1- starting
    zeros = []
    for i, line in enumerate(open(filename)):
        if i+1 < m:
            continue
        if i+1 > n:
            break
        y = mpf(line.strip())
        zeros.append(y)
        if i+1 == m:
            t1 = y
    t2 = y
    return zeros, t1, t2

def delta_n(n, zeros):
    """Normalized spacing between neighboring zeros. This is the main 
    modification to take into account for the high density at large points 
    on the line. `zeros` should be a list of zeros (imaginary part only).
    
    """
    #return log(zeros[n]/2.0/pi/e)/2.0/pi*(zeros[n+1]-zeros[n])
    return log(zeros[n]/2.0/pi)/2.0/pi*(zeros[n+1]-zeros[n])

def pair_correlation(zeros, alpha, beta):
    """Compute the pair correlation between Riemann zeros."""
    summatory = 0
    num_zeros = len(zeros)
    for n in range(num_zeros-1): # delta_n takes zeros[n+1]
        for k in range(num_zeros-n-1): # delta_n can take until zeros[n+k+1]
            delta = sum([delta_n(n+a, zeros) for a in range(k)])
            if alpha < delta <= beta:
                summatory += 1
            elif delta > beta: # if larger for k, it will also for higher k's
                break
    #x = (alpha + beta)/2.0
    return float(summatory)

def gue_correlation(alpha, beta):
    """Compute the GUE 2-point correlation function."""
    f = lambda x: 1.0 - power(sin(pi*x)/(pi*x), 2)
    result = quad(f, [alpha, beta])
    #x = (alpha + beta)/2.0
    return result

def normalize(in_file, out_file, p=1, g=1):
    """Normalize the points generated by the pair correlation
    computation. Take the highest one and promote to 1, then
    re-escale everybody. We can also normalize the GUE data if wanted.
    
    """
    f = open(in_file)
    out = open(out_file, 'w')
    xvalues = []
    corrvalues = []
    guevalues = []
    for line in f:
        (x, corr, gue) = line.strip().split('\t')
        xvalues.append(float(x))
        corrvalues.append(mpf(corr))
        guevalues.append(mpf(gue))
    p = max(corrvalues)
    corrvalues_norm = [x/p for x in corrvalues]
    guevalues_norm = [x/g for x in guevalues]
    for a in zip(xvalues, corrvalues_norm, guevalues_norm):
        out.write('%.4f\t%.10f\t%.10f\n' % a)

def main(highest, lowest, alpha, step, input_file, output_file, starting=0):
    """Generate data for the pair correlation conjecture.
    The data will be written to a file.
    
    Example of parameters

    highest = 100000       # the number of highest Riemann zero
    lowest  = 90000        # the number of lowest Riemann zero
    alpha = [0.0, 1.95]    # the range of alpha interval
    step = 0.05            # for each alpha, beta = alpha + step
    input_file = 'zeros1.txt'
    output_file = 'pair_correlation_data.txt'
    
    """
    difference = highest - lowest
    alphas = arange(alpha[0], alpha[1], step)
    betas = arange(alpha[0]+step, alpha[1]+step, step)
    zeros, t1, t2 = get_zeros(lowest, highest, input_file, starting)
    out = open(output_file, 'w')
    last_point = (alphas[-1] + betas[-1]) / 2.0
    for a, b in zip(alphas, betas):
        x = (a+b)/2.0
        corr = pair_correlation(zeros, a, b)/mpf(difference)/step
        gue = gue_correlation(a, b)/step
        out.write('%.4f\t%.10f\t%.10f\n' % (x, corr, gue))
        print 'Doing point %.4f of %.4f' % (x, last_point)

